<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE BLOW FILM SIMULATOR v4.0 | Industrial Engineering</title>
    <!-- 
        BIBLIOTECAS EXTERNAS:
        Three.js: Renderização 3D Core
        Tween.js: Transições Suaves de Parâmetros
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <style>
        /* 
           ==========================================================================
           ESTILO CSS - DESIGN INDUSTRIAL E RESPONSIVIDADE
           ==========================================================================
        */
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&family=Rajdhani:wght@300;400;500;600;700&display=swap');

        :root {
            --primary: #00b4ff;
            --secondary: #00ff88;
            --warning: #ffcc00;
            --danger: #ff3e3e;
            --bg-dark: #020508;
            --panel-bg: rgba(7, 15, 25, 0.95);
            --border: rgba(0, 180, 255, 0.2);
            --font-main: 'Rajdhani', sans-serif;
            --font-code: 'JetBrains Mono', monospace;
            --transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-dark);
            color: #e0f0f5;
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Container Principal 3D */
        #viewport {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            cursor: grab;
        }
        #viewport:active { cursor: grabbing; }

        /* 
           INTERFACE DE USUÁRIO (HMI) 
        */
        .hmi-panel {
            position: absolute;
            height: 100vh;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            border-color: var(--border);
            border-style: solid;
            transition: var(--transition);
        }

        /* Painel de Controle (Esquerdo) */
        #hmi-controls {
            left: 0;
            width: 380px;
            border-right-width: 1px;
            transform: translateX(0);
        }

        /* Painel de Dados (Direito) */
        #hmi-data {
            right: 0;
            width: 340px;
            border-left-width: 1px;
            transform: translateX(0);
        }

        /* Mobile Adjustments */
        @media (max-width: 1100px) {
            #hmi-controls { width: 320px; transform: translateX(-100%); }
            #hmi-data { width: 300px; transform: translateX(100%); }
            #hmi-controls.open { transform: translateX(0); }
            #hmi-data.open { transform: translateX(0); }
        }

        /* Header do Painel */
        .panel-header {
            padding: 25px 20px;
            background: rgba(0, 180, 255, 0.05);
            border-bottom: 1px solid var(--border);
        }

        .panel-header h2 {
            font-size: 18px;
            letter-spacing: 3px;
            color: var(--primary);
            text-transform: uppercase;
        }

        .panel-header p {
            font-size: 10px;
            font-family: var(--font-code);
            opacity: 0.5;
            margin-top: 5px;
        }

        /* Scroll Area */
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Seções de Controle */
        .control-section {
            margin-bottom: 25px;
        }

        .section-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .section-label::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
            margin-left: 10px;
        }

        /* Group Row */
        .input-group {
            margin-bottom: 18px;
        }

        .input-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .input-title { font-size: 13px; font-weight: 500; }
        .input-val { 
            font-family: var(--font-code); 
            font-size: 12px; 
            color: var(--primary);
            background: rgba(0, 180, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 0 15px var(--primary);
            border: 2px solid #fff;
        }

        /* Blend Bar */
        .blend-viz {
            height: 14px;
            width: 100%;
            background: #000;
            border-radius: 7px;
            display: flex;
            overflow: hidden;
            margin-top: 10px;
            border: 1px solid var(--border);
        }
        .blend-seg { height: 100%; transition: width 0.5s ease; }
        .seg-ldpe { background: var(--secondary); }
        .seg-hdpe { background: var(--primary); }
        .seg-lldpe { background: var(--warning); }

        /* Telemetria Cards */
        .telemetry-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .tele-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .tele-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 5px; }
        .tele-val { font-size: 22px; font-weight: 700; font-family: var(--font-code); }

        /* Gráfico Canvas */
        .chart-container {
            flex: 1;
            min-height: 300px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-top: 10px;
            position: relative;
            padding: 10px;
        }

        canvas#process-chart { width: 100%; height: 100%; }

        /* Mobile Bottom Nav */
        #mobile-nav {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(10, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 50px;
            border: 1px solid var(--border);
            gap: 10px;
        }

        @media (max-width: 1100px) { #mobile-nav { display: flex; } }

        .nav-item {
            padding: 10px 20px;
            border-radius: 25px;
            background: transparent;
            border: 1px solid transparent;
            color: #fff;
            font-family: var(--font-main);
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            cursor: pointer;
        }
        .nav-item.active {
            background: var(--primary);
            color: #000;
        }

        /* Alertas */
        #scada-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-150%);
            z-index: 2000;
            background: var(--danger);
            color: #fff;
            padding: 15px 40px;
            border-radius: 50px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.5s;
            box-shadow: 0 10px 40px rgba(255, 62, 62, 0.5);
        }
        #scada-alert.visible { transform: translateX(-50%) translateY(0); }

        /* Heater Band Tooltip Style */
        .heater-label {
            position: absolute;
            background: rgba(0,0,0,0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-family: var(--font-code);
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>

    <div id="scada-alert">⚠ FALHA DE ESTABILIDADE: RUPTURA IMINENTE</div>

    <!-- NAVEGAÇÃO MOBILE -->
    <div id="mobile-nav">
        <button class="nav-item" id="nav-set" onclick="toggleHMI('left')">Ajustes</button>
        <button class="nav-item" id="nav-cam" onclick="toggleHMI('none')">Câmera</button>
        <button class="nav-item" id="nav-dat" onclick="toggleHMI('right')">Dados</button>
    </div>

    <!-- VIEWPORT 3D -->
    <div id="viewport"></div>

    <!-- PAINEL ESQUERDO: HMI SETTINGS -->
    <aside id="hmi-controls" class="hmi-panel">
        <div class="panel-header">
            <h2>HMI Controller</h2>
            <p>SISTEMA DE GESTÃO DE EXTRUSÃO MULTICAMADA</p>
        </div>
        
        <div class="panel-content">
            <!-- 1. Blend Reology -->
            <div class="control-section">
                <div class="section-label">Blend de Materiais</div>
                
                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">LDPE (Baixa Densidade)</span>
                        <span class="input-val" id="val-ldpe">50%</span>
                    </div>
                    <input type="range" id="in-ldpe" min="0" max="100" value="50" oninput="engine.updateBlend()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">HDPE (Alta Densidade)</span>
                        <span class="input-val" id="val-hdpe">20%</span>
                    </div>
                    <input type="range" id="in-hdpe" min="0" max="100" value="20" oninput="engine.updateBlend()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">LLDPE (Linear)</span>
                        <span class="input-val" id="val-lldpe">30%</span>
                    </div>
                    <input type="range" id="in-lldpe" min="0" max="100" value="30" oninput="engine.updateBlend()">
                </div>

                <div class="blend-viz">
                    <div id="bar-ldpe" class="blend-seg seg-ldpe" style="width: 50%;"></div>
                    <div id="bar-hdpe" class="blend-seg seg-hdpe" style="width: 20%;"></div>
                    <div id="bar-lldpe" class="blend-seg seg-lldpe" style="width: 30%;"></div>
                </div>
            </div>

            <!-- 2. Thermal & Flow -->
            <div class="control-section">
                <div class="section-label">Térmica e Fluxo</div>
                
                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Temperatura Fundido</span>
                        <span class="input-val" id="val-temp">195°C</span>
                    </div>
                    <input type="range" id="in-temp" min="150" max="260" value="195" oninput="engine.updateParams()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Ar de Resfriamento</span>
                        <span class="input-val" id="val-cool">1400 m³/h</span>
                    </div>
                    <input type="range" id="in-cool" min="200" max="3500" value="1400" oninput="engine.updateParams()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Auxiliar de Fluxo (PPA)</span>
                        <span class="input-val" id="val-ppa">0.8%</span>
                    </div>
                    <input type="range" id="in-ppa" min="0" max="5" value="0.8" step="0.1" oninput="engine.updateParams()">
                </div>
            </div>

            <!-- 3. Geometry & Mechanical -->
            <div class="control-section">
                <div class="section-label">Cinemática e Die</div>
                
                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Pressão Interna (Insufl.)</span>
                        <span class="input-val" id="val-press">48 mbar</span>
                    </div>
                    <input type="range" id="in-press" min="5" max="150" value="48" oninput="engine.updateParams()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Velocidade Puxamento</span>
                        <span class="input-val" id="val-speed">28 m/min</span>
                    </div>
                    <input type="range" id="in-speed" min="2" max="120" value="28" oninput="engine.updateParams()">
                </div>

                <div class="input-group">
                    <div class="input-header">
                        <span class="input-title">Diâmetro da Die (mm)</span>
                        <span class="input-val" id="val-dieD">180</span>
                    </div>
                    <input type="range" id="in-dieD" min="80" max="400" value="180" oninput="engine.updateParams()">
                </div>
            </div>
        </div>
    </aside>

    <!-- PAINEL DIREITO: TELEMETRIA E GRÁFICOS -->
    <aside id="hmi-data" class="hmi-panel">
        <div class="panel-header">
            <h2>Process Telemetry</h2>
            <p>ANÁLISE REOLÓGICA EM TEMPO REAL</p>
        </div>

        <div class="panel-content">
            <div class="telemetry-grid">
                <div class="tele-card">
                    <div class="tele-label">BUR</div>
                    <div id="out-bur" class="tele-val">2.55</div>
                </div>
                <div class="tele-card">
                    <div class="tele-label">DDR</div>
                    <div id="out-ddr" class="tele-val">18.4</div>
                </div>
                <div class="tele-card">
                    <div class="tele-label">Espessura</div>
                    <div id="out-thick" class="tele-val" style="color: var(--secondary);">35 µm</div>
                </div>
                <div class="tele-card">
                    <div class="tele-label">Estabilidade</div>
                    <div id="out-stab" class="tele-val">96%</div>
                </div>
            </div>

            <div class="section-label">Perfil de Estiramento</div>
            <div class="chart-container">
                <canvas id="process-chart"></canvas>
            </div>

            <div style="margin-top: 20px; font-size: 11px; font-family: var(--font-code); color: var(--text-muted); line-height: 1.6;">
                <p>> MONITORAMENTO DE CRISTALIZAÇÃO ATIVO</p>
                <p>> GRADIENTE TÉRMICO: OK</p>
                <p>> TAXA DE CISALHAMENTO: 45.2 s⁻¹</p>
                <p>> VISCOSIDADE DINÂMICA: 850 Pa.s</p>
            </div>
        </div>
    </aside>

    <script>
        /**
         * ==========================================================================
         * CORE SIMULATOR ENGINE (JAVASCRIPT)
         * Uma implementação massiva focada em física e realismo visual.
         * ==========================================================================
         */

        const engine = {
            // Configurações Globais
            config: {
                LDPE_DENSITY: 0.922,
                HDPE_DENSITY: 0.958,
                LLDPE_DENSITY: 0.918,
                NIP_HEIGHT: 24.0, // Altura dos rolos de puxamento
                RESOLUTION: 120,   // Resolução vertical do balão
                RADIAL_SEGMENTS: 72 // Resolução circular
            },

            // Estado Atual da Simulação
            state: {
                materials: { ldpe: 50, hdpe: 20, lldpe: 30, ppa: 0.8 },
                process: { temp: 195, cool: 1400, press: 48, speed: 28, dieD: 180, dieGap: 1.5 },
                results: { bur: 0, ddr: 0, flh: 0, thickness: 0, stability: 100, stalkH: 0 },
                camera: { theta: 0.8, phi: 1.1, radius: 30, target: new THREE.Vector3(0, 10, 0) }
            },

            // Instâncias Three.js
            scene: null,
            camera: null,
            renderer: null,
            clock: null,
            meshes: {
                balloon: null,
                die: null,
                extruder: null,
                nips: null,
                frostRing: null,
                particles: null
            },

            // 1. INICIALIZAÇÃO
            init() {
                const container = document.getElementById('viewport');
                
                // Scene Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020508);
                this.scene.fog = new THREE.FogExp2(0x020508, 0.012);

                // Camera Setup
                this.camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 2000);
                
                // Renderer Setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                container.appendChild(this.renderer.domElement);

                this.clock = new THREE.Clock();

                // Build World
                this.setupLights();
                this.buildEnvironment();
                this.buildExtruderGroup();
                this.buildNipRolls();
                this.setupControls();

                // Init Logic
                this.updateBlend();
                this.animate();

                window.addEventListener('resize', () => this.onResize());
            },

            setupLights() {
                const amb = new THREE.AmbientLight(0x1a2a3a, 1.2);
                this.scene.add(amb);

                const mainDir = new THREE.DirectionalLight(0xffffff, 1.5);
                mainDir.position.set(20, 50, 30);
                mainDir.castShadow = true;
                mainDir.shadow.mapSize.set(2048, 2048);
                this.scene.add(mainDir);

                const blueFill = new THREE.PointLight(0x00b4ff, 1.0, 100);
                blueFill.position.set(-20, 10, -20);
                this.scene.add(blueFill);

                const orangeGlow = new THREE.PointLight(0xff4400, 4, 15);
                orangeGlow.position.set(0, 3.5, 0);
                this.scene.add(orangeGlow);
            },

            buildEnvironment() {
                const grid = new THREE.GridHelper(100, 50, 0x00b4ff, 0x05101a);
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                grid.position.y = -0.1;
                this.scene.add(grid);

                const floorGeo = new THREE.PlaneGeometry(200, 200);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x020508, roughness: 0.1, metalness: 0.5 });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI/2;
                floor.receiveShadow = true;
                this.scene.add(floor);
            },

            // 2. CONSTRUÇÃO DA EXTRUSORA INDUSTRIAL
            buildExtruderGroup() {
                this.meshes.extruder = new THREE.Group();
                const matMetal = new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.2, metalness: 0.8 });
                const matDark = new THREE.MeshStandardMaterial({ color: 0x111820, roughness: 0.6, metalness: 0.4 });
                const matHeater = new THREE.MeshStandardMaterial({ color: 0xaa3311, emissive: 0x551100, roughness: 0.8 });

                // Redutor (Gearbox)
                const gearBox = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 2.5), matDark);
                gearBox.position.set(-7.5, 1.25, 0);
                this.meshes.extruder.add(gearBox);

                // Canhão (Barrel)
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 6, 48), matMetal);
                barrel.rotation.z = Math.PI/2;
                barrel.position.set(-3.5, 1.6, 0);
                this.meshes.extruder.add(barrel);

                // Heater Bands (Resistências)
                for(let i=0; i<6; i++) {
                    const heater = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.85, 0.4, 32), matHeater);
                    heater.rotation.z = Math.PI/2;
                    heater.position.set(-5.5 + (i * 0.9), 1.6, 0);
                    this.meshes.extruder.add(heater);
                }

                // Funil (Hopper)
                const hopper = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 0.3, 2.2, 16), matMetal);
                hopper.position.set(-6.0, 3.5, 0);
                this.meshes.extruder.add(hopper);

                // Cabeçote (Die Head)
                this.meshes.die = new THREE.Group();
                this.meshes.die.position.set(0.5, 2.5, 0);

                const dieBase = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 0.6, 64), matDark);
                this.meshes.die.add(dieBase);

                const dieBody = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.6, 1.4, 64), matMetal);
                dieBody.position.y = 1.0;
                this.meshes.die.add(dieBody);

                // Dual Lip Air Ring
                const airRingLower = new THREE.Mesh(new THREE.CylinderGeometry(2.2, 2.2, 0.5, 64), matDark);
                airRingLower.position.y = 1.9;
                this.meshes.die.add(airRingLower);

                const airRingUpper = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.4, 32, 64), matDark);
                airRingUpper.rotation.x = Math.PI/2;
                airRingUpper.position.y = 2.3;
                this.meshes.die.add(airRingUpper);

                // Die Lip (Saída)
                const lip = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.08, 16, 64), matDark);
                lip.rotation.x = Math.PI/2;
                lip.position.y = 1.8;
                this.meshes.die.add(lip);

                this.meshes.extruder.add(this.meshes.die);
                this.scene.add(this.meshes.extruder);
            },

            buildNipRolls() {
                this.meshes.nips = new THREE.Group();
                this.meshes.nips.position.y = this.config.NIP_HEIGHT + 2.5;
                this.meshes.nips.position.x = 0.5;

                const rollGeo = new THREE.CylinderGeometry(0.5, 0.5, 8.0, 32);
                const mat = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.3, metalness: 0.6 });

                const r1 = new THREE.Mesh(rollGeo, mat);
                r1.rotation.z = Math.PI/2; r1.position.z = 0.55;
                const r2 = new THREE.Mesh(rollGeo, mat);
                r2.rotation.z = Math.PI/2; r2.position.z = -0.55;

                this.meshes.nips.add(r1, r2);
                this.scene.add(this.meshes.nips);
            },

            // 3. LOGICA REOLÓGICA E DE MISTURA
            updateBlend() {
                const ld = parseFloat(document.getElementById('in-ldpe').value);
                const hd = parseFloat(document.getElementById('in-hdpe').value);
                const li = parseFloat(document.getElementById('in-lldpe').value);
                
                const total = ld + hd + li || 1;
                this.state.materials.ldpe = (ld/total) * 100;
                this.state.materials.hdpe = (hd/total) * 100;
                this.state.materials.lldpe = (li/total) * 100;

                // Update UI
                document.getElementById('val-ldpe').innerText = Math.round(this.state.materials.ldpe) + "%";
                document.getElementById('val-hdpe').innerText = Math.round(this.state.materials.hdpe) + "%";
                document.getElementById('val-lldpe').innerText = Math.round(this.state.materials.lldpe) + "%";
                
                document.getElementById('bar-ldpe').style.width = this.state.materials.ldpe + "%";
                document.getElementById('bar-hdpe').style.width = this.state.materials.hdpe + "%";
                document.getElementById('bar-lldpe').style.width = this.state.materials.lldpe + "%";

                this.updateParams();
            },

            updateParams() {
                const p = this.state.process;
                p.temp = parseFloat(document.getElementById('in-temp').value);
                p.cool = parseFloat(document.getElementById('in-cool').value);
                p.press = parseFloat(document.getElementById('in-press').value);
                p.speed = parseFloat(document.getElementById('in-speed').value);
                p.dieD = parseFloat(document.getElementById('in-dieD').value);
                this.state.materials.ppa = parseFloat(document.getElementById('in-ppa').value);

                document.getElementById('val-temp').innerText = p.temp + "°C";
                document.getElementById('val-cool').innerText = p.cool + " m³/h";
                document.getElementById('val-press').innerText = p.press + " mbar";
                document.getElementById('val-speed').innerText = p.speed + " m/min";
                document.getElementById('val-dieD').innerText = p.dieD + " mm";
                document.getElementById('val-ppa').innerText = this.state.materials.ppa.toFixed(1) + "%";

                // FISICA: BUR e DDR
                const m = this.state.materials;
                const density = (m.ldpe * this.config.LDPE_DENSITY + m.hdpe * this.config.HDPE_DENSITY + m.lldpe * this.config.LLDPE_DENSITY) / 100;
                
                // BUR (Blow Up Ratio)
                let meltResistance = 1.0 + (m.hdpe / 50) + ((220 - p.temp) / 80);
                this.state.results.bur = 1.0 + (p.press / (35 * meltResistance));
                this.state.results.bur = Math.max(1.1, Math.min(this.state.results.bur, 4.6));

                // DDR (Draw Down Ratio)
                const dieArea = Math.PI * (p.dieD * 0.001) * (p.dieGap * 0.001);
                const massFlow = 150 * (p.speed / 50); // Simulado
                const vExt = (massFlow / 3600) / (density * 1000 * dieArea);
                this.state.results.ddr = (p.speed / 60) / Math.max(vExt, 0.001);

                // Espessura
                this.state.results.thickness = (p.dieGap * 1000) / (this.state.results.bur * this.state.results.ddr);
                
                // FLH (Frost Line Height) - Aumenta com temp e fluxo, diminui com cooling
                this.state.results.flh = (6.0 * (p.temp - 140)/60) / (p.cool/1100);
                this.state.results.flh = Math.max(2.0, Math.min(this.state.results.flh, 15.0));

                // Stalk Height (Pescoço do HDPE)
                this.state.results.stalkH = this.state.results.flh * 0.75 * Math.pow(m.hdpe/100, 1.4);

                // Estabilidade
                let stab = 100 - (Math.abs(this.state.results.bur - 2.5) * 12) - (p.speed / 8);
                if(p.temp < 175) stab -= (175 - p.temp);
                stab += m.ppa * 4;
                this.state.results.stability = Math.max(0, Math.min(100, stab));

                this.updateUI();
                this.rebuildBalloon();
            },

            updateUI() {
                const r = this.state.results;
                document.getElementById('out-bur').innerText = r.bur.toFixed(2);
                document.getElementById('out-ddr').innerText = r.ddr.toFixed(1);
                document.getElementById('out-thick').innerText = Math.round(r.thickness) + " µm";
                document.getElementById('out-stab').innerText = Math.round(r.stability) + "%";

                const alert = document.getElementById('scada-alert');
                if(r.stability < 40) alert.classList.add('visible');
                else alert.classList.remove('visible');

                this.drawProcessChart();
            },

            // 4. GEOMETRIA DO BALÃO (ACHATAMENTO AVANÇADO)
            rebuildBalloon() {
                if(this.meshes.balloon) {
                    this.scene.remove(this.meshes.balloon);
                    this.meshes.balloon.geometry.dispose();
                }

                const r = this.state.results;
                const p = this.state.process;
                
                const dieRad = (p.dieD / 2) / 100;
                const maxRad = dieRad * r.bur;
                
                const geo = new THREE.CylinderGeometry(1, 1, this.config.NIP_HEIGHT, this.config.RADIAL_SEGMENTS, this.config.RESOLUTION, true);
                geo.translate(0, this.config.NIP_HEIGHT/2, 0);

                const pos = geo.attributes.position;
                const colors = [];
                const flattenZone = 5.0; // Início do achatamento antes dos rolos

                for(let i=0; i<pos.count; i++) {
                    const row = Math.floor(i / (this.config.RADIAL_SEGMENTS + 1));
                    const col = i % (this.config.RADIAL_SEGMENTS + 1);
                    const y = this.config.NIP_HEIGHT * (1 - row/this.config.RESOLUTION);
                    const theta = (col / this.config.RADIAL_SEGMENTS) * Math.PI * 2;

                    // 1. Perfil do Raio
                    let currentR = dieRad;
                    if(y <= r.stalkH) {
                        currentR = dieRad + (y/r.stalkH) * 0.08;
                    } else if(y <= r.flh) {
                        const t = (y - r.stalkH) / (r.flh - r.stalkH);
                        const smoothT = t * t * (3 - 2 * t);
                        currentR = (dieRad + 0.08) + (maxRad - (dieRad + 0.08)) * smoothT;
                    } else {
                        currentR = maxRad;
                    }

                    // 2. Achatamento (Flattening)
                    let x = Math.cos(theta) * currentR;
                    let z = Math.sin(theta) * currentR;

                    if(y > (this.config.NIP_HEIGHT - flattenZone)) {
                        const f = (y - (this.config.NIP_HEIGHT - flattenZone)) / flattenZone;
                        const smoothF = f * f * (3 - 2 * f);
                        
                        z *= (1 - smoothF); // Z vai para zero (esmagado)
                        // X expande para Pi*R/2 para manter circunferência
                        const targetX = Math.sign(Math.cos(theta)) * (currentR * Math.PI / 2) * Math.abs(Math.cos(theta));
                        x = x * (1 - smoothF) + targetX * smoothF;
                    }

                    pos.setXYZ(i, x, y, z);

                    // 3. Gradiente de Cor (Quente -> Frio)
                    const c = new THREE.Color();
                    if(y < r.flh) {
                        const t = y / r.flh;
                        c.setHSL(0.06 - t*0.02, 1.0, 0.5); // Laranja para Amarelo
                    } else {
                        c.setHSL(0.55, 0.6, 0.7); // Azul Translúcido
                    }
                    colors.push(c.r, c.g, c.b);
                }

                geo.computeVertexNormals();
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const mat = new THREE.MeshPhysicalMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    roughness: 0.2,
                    transmission: 0.5,
                    thickness: 1.0
                });

                this.meshes.balloon = new THREE.Mesh(geo, mat);
                this.meshes.balloon.position.set(0.5, 4.3, 0);
                this.scene.add(this.meshes.balloon);
            },

            // 5. GRÁFICOS E ANIMAÇÃO
            drawProcessChart() {
                const canvas = document.getElementById('process-chart');
                const ctx = canvas.getContext('2d');
                const w = canvas.offsetWidth;
                const h = canvas.offsetHeight;
                canvas.width = w; canvas.height = h;

                ctx.clearRect(0,0,w,h);
                
                // Desenha Eixo Central
                ctx.strokeStyle = "rgba(255,255,255,0.1)";
                ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();

                // Desenha Curva de Resfriamento (Simulada)
                ctx.strokeStyle = varToHex('--primary');
                ctx.lineWidth = 3;
                ctx.beginPath();
                const r = this.state.results;
                for(let i=0; i<h; i++) {
                    const yNormal = 1 - (i/h);
                    const yReal = yNormal * this.config.NIP_HEIGHT;
                    let rad = 0;
                    if(yReal < r.flh) rad = 20 + (yReal/r.flh)*40;
                    else rad = 60;
                    
                    const x = w/2 + (rad * (w/200)) * this.state.results.bur;
                    if(i === 0) ctx.moveTo(x, i);
                    else ctx.lineTo(x, i);
                }
                ctx.stroke();

                // Linha de Névoa (FLH) no Gráfico
                const flhY = h - (r.flh / this.config.NIP_HEIGHT) * h;
                ctx.strokeStyle = varToHex('--secondary');
                ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(0, flhY); ctx.lineTo(w, flhY); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = varToHex('--secondary');
                ctx.font = "10px monospace";
                ctx.fillText("FROST LINE", 10, flhY - 5);
            },

            setupControls() {
                let isDragging = false;
                let lastMouse = { x: 0, y: 0 };

                const viewport = document.getElementById('viewport');

                const start = (x, y) => { isDragging = true; lastMouse.x = x; lastMouse.y = y; };
                const move = (x, y) => {
                    if(!isDragging) return;
                    const dx = x - lastMouse.x;
                    const dy = y - lastMouse.y;
                    this.state.camera.theta -= dx * 0.005;
                    this.state.camera.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.state.camera.phi + dy * 0.005));
                    lastMouse.x = x; lastMouse.y = y;
                };

                viewport.addEventListener('mousedown', e => start(e.clientX, e.clientY));
                window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
                window.addEventListener('mouseup', () => isDragging = false);

                viewport.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY));
                viewport.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY));
                window.addEventListener('touchend', () => isDragging = false);

                viewport.addEventListener('wheel', e => {
                    this.state.camera.radius = Math.max(15, Math.min(100, this.state.camera.radius + e.deltaY * 0.05));
                });
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                const t = this.clock.getElapsedTime();

                // Camera Lerp
                const cam = this.state.camera;
                const targetPos = new THREE.Vector3().setFromSphericalCoords(cam.radius, cam.phi, cam.theta).add(cam.target);
                this.camera.position.lerp(targetPos, 0.1);
                this.camera.lookAt(cam.target);

                // Bubble Wobble (Instabilidade)
                if(this.meshes.balloon) {
                    const stab = this.state.results.stability;
                    if(stab < 70) {
                        const w = (70 - stab) * 0.002;
                        this.meshes.balloon.rotation.x = Math.sin(t * 3) * w;
                        this.meshes.balloon.rotation.z = Math.cos(t * 2.5) * w;
                    } else {
                        this.meshes.balloon.rotation.x *= 0.9;
                        this.meshes.balloon.rotation.z *= 0.9;
                    }
                }

                // Nip Roll Animation
                if(this.meshes.nips) {
                    const s = this.state.process.speed * 0.02;
                    this.meshes.nips.children[0].rotation.x += s;
                    this.meshes.nips.children[1].rotation.x -= s;
                }

                this.renderer.render(this.scene, this.camera);
            },

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.drawProcessChart();
            }
        };

        // Utility: Get CSS Var
        function varToHex(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        // HMI Interaction
        function toggleHMI(side) {
            const left = document.getElementById('hmi-controls');
            const right = document.getElementById('hmi-data');
            const btns = document.querySelectorAll('.nav-item');
            
            btns.forEach(b => b.classList.remove('active'));

            if(side === 'left') {
                left.classList.add('open'); right.classList.remove('open');
                document.getElementById('nav-set').classList.add('active');
            } else if(side === 'right') {
                right.classList.add('open'); left.classList.remove('open');
                document.getElementById('nav-dat').classList.add('active');
            } else {
                left.classList.remove('open'); right.classList.remove('open');
                document.getElementById('nav-cam').classList.add('active');
            }
        }

        // Start Engine
        window.onload = () => engine.init();

    </script>
</body>
</html>
